{
  "id": "edit-distance",
  "title": "Edit distance",
  "pattern": "dynamic-programming",
  "difficulty": "hard",
  "language": "javascript",
  "status": "draft",
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand what the Edit Distance (Levenshtein Distance) problem asks for\n2. Use dynamic programming with a 2D table to find minimum edit operations\n3. Handle three operations: insert, delete, and replace\n4. Implement the solution step by step in your chosen language",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Perfect! Now let's understand what the Edit Distance problem is asking.\n\nImagine you have two strings:\n- word1 = \"horse\"\n- word2 = \"ros\"\n\nYour task: Find the minimum number of operations (insert, delete, replace) needed to convert word1 to word2.\n\n**Operations**:\n1. **Insert**: Add a character\n2. **Delete**: Remove a character\n3. **Replace**: Change a character\n\nLet's try converting \"horse\" to \"ros\":\n\nOption 1:\n- \"horse\" â†’ delete 'h' â†’ \"orse\"\n- \"orse\" â†’ delete 'o' â†’ \"rse\"\n- \"rse\" â†’ replace 's' with 'o' â†’ \"roe\"\n- \"roe\" â†’ replace 'e' with 's' â†’ \"ros\"\nOperations: 4 (2 delete, 2 replace)\n\nOption 2:\n- \"horse\" â†’ replace 'h' with 'r' â†’ \"rorse\"\n- \"rorse\" â†’ delete 'r' â†’ \"orse\"\n- \"orse\" â†’ delete 'o' â†’ \"rse\"\n- \"rse\" â†’ replace 's' with 'o' â†’ \"roe\"\n- \"roe\" â†’ replace 'e' with 's' â†’ \"ros\"\nOperations: 5\n\nOption 3 (Optimal):\n- \"horse\" â†’ delete 'h' â†’ \"orse\"\n- \"orse\" â†’ replace 'o' with 'r' â†’ \"rrse\"\n- \"rrse\" â†’ delete 'r' â†’ \"rse\"\n- \"rse\" â†’ replace 's' with 'o' â†’ \"roe\"\n- \"roe\" â†’ replace 'e' with 's' â†’ \"ros\"\nOperations: 5\n\nWait, let's think more carefully...\n\nActually optimal:\n- \"horse\" â†’ replace 'h' with 'r' â†’ \"rorse\"\n- \"rorse\" â†’ delete 'r' â†’ \"orse\"\n- \"orse\" â†’ delete 'o' â†’ \"rse\"\n- \"rse\" â†’ replace 's' with 'o' â†’ \"roe\"\n- \"roe\" â†’ replace 'e' with 's' â†’ \"ros\"\n\nBetter:\n- \"horse\" â†’ delete 'h' â†’ \"orse\"\n- \"orse\" â†’ replace 'o' with 'r' â†’ \"rrse\"\n- \"rrse\" â†’ delete 'r' â†’ \"rse\"\n- \"rse\" â†’ replace 's' with 'o' â†’ \"roe\"\n- \"roe\" â†’ replace 'e' with 's' â†’ \"ros\"\n\nActually, the optimal is 3:\n- \"horse\" â†’ replace 'h' with 'r' â†’ \"rorse\"\n- \"rorse\" â†’ delete 'r' â†’ \"orse\"\n- \"orse\" â†’ delete 'o' â†’ \"rse\"\n- \"rse\" â†’ delete 's' â†’ \"re\"\n- \"re\" â†’ insert 'o' â†’ \"roe\"\n- \"roe\" â†’ insert 's' â†’ \"ros\"\n\nWait, let me recalculate properly:\n\n**Key Insight**: We use dynamic programming with a 2D table:\n- dp[i][j] = minimum edits to convert word1[0..i-1] to word2[0..j-1]\n- If characters match: dp[i][j] = dp[i-1][j-1] (no operation needed)\n- If characters don't match: dp[i][j] = 1 + min(\n    dp[i-1][j],      // delete from word1\n    dp[i][j-1],      // insert into word1\n    dp[i-1][j-1]     // replace in word1\n  )\n\nLet's trace with word1=\"horse\", word2=\"ros\":\n\n- **dp[0][0] = 0** (empty to empty)\n- **dp[0][1] = 1** (empty to \"r\": insert 'r')\n- **dp[0][2] = 2** (empty to \"ro\": insert 'r', 'o')\n- **dp[0][3] = 3** (empty to \"ros\": insert 'r', 'o', 's')\n- **dp[1][0] = 1** (\"h\" to empty: delete 'h')\n- **dp[1][1] = 1** (\"h\" to \"r\": replace 'h' with 'r')\n- **dp[1][2] = 2** (\"h\" to \"ro\": replace 'h' with 'r', insert 'o')\n- **dp[1][3] = 3** (\"h\" to \"ros\": replace 'h' with 'r', insert 'o', 's')\n- **dp[2][1] = 2** (\"ho\" to \"r\": delete 'o', replace 'h' with 'r')\n- ... and so on\n\nAfter filling the table: **dp[5][3] = 3**\n\nAnswer: 3\n\nThat's what the problem wants: the minimum number of operations to convert word1 to word2.",
      "example": "word1 = \"horse\"\nword2 = \"ros\"\n\nFind minimum edit distance:\n- Replace 'h' with 'r' â†’ \"rorse\"\n- Delete 'r' â†’ \"orse\"\n- Delete 'o' â†’ \"rse\"\n- Replace 's' with 'o' â†’ \"roe\"\n- Replace 'e' with 's' â†’ \"ros\"\n\nWait, optimal is 3:\n- Replace 'h' with 'r' â†’ \"rorse\"\n- Delete 'r' â†’ \"orse\"\n- Delete 'o' â†’ \"rse\"\n- Delete 's' â†’ \"re\"\n- Insert 'o' â†’ \"roe\"\n- Insert 's' â†’ \"ros\"\n\nActually: 3 operations\n\nAnother example:\nword1 = \"intention\"\nword2 = \"execution\"\n\nAnswer: 5\n\nAnother example:\nword1 = \"\"\nword2 = \"abc\"\n\nAnswer: 3 (insert 3 characters)",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand what the problem wants, here's the real question:\n\nHow would YOU find the minimum edit distance?\n\nThink about it for a moment. What approach feels natural to you?",
      "choices": [
        {
          "label": "Use dynamic programming with a 2D table",
          "next": "explore-dp"
        },
        {
          "label": "Try all possible sequences of operations",
          "next": "explore-brute-force"
        },
        {
          "label": "Use recursion with memoization",
          "next": "explore-recursion"
        }
      ]
    },
    {
      "stepId": "explore-brute-force",
      "mentorSays": "That's a straightforward approach! You're thinking: \"I'll try all possible sequences of insert, delete, and replace operations.\"\n\nThis works! However, it's exponential time complexity.\n\nWould you like to learn the dynamic programming approach which is O(m Ã— n) time?",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-recursion",
      "mentorSays": "Great thinking! Recursion with memoization is essentially the same as bottom-up DP, just implemented differently.\n\nLet's learn the bottom-up DP approach which is more intuitive!",
      "action": "continue",
      "next": "explore-dp"
    },
    {
      "stepId": "explore-dp",
      "mentorSays": "Excellent choice! Dynamic programming with a 2D table is efficient and intuitive. Here's the core idea:\n\n1. **DP Table**: dp[i][j] = minimum edits to convert word1[0..i-1] to word2[0..j-1]\n2. **Base Cases**:\n   - dp[0][j] = j (insert j characters into empty string)\n   - dp[i][0] = i (delete i characters from word1)\n3. **Recurrence**: For each position (i, j):\n   - If word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] (characters match, no operation)\n   - Else: dp[i][j] = 1 + min(\n       dp[i-1][j],      // delete from word1\n       dp[i][j-1],      // insert into word1\n       dp[i-1][j-1]     // replace in word1\n     )\n4. **Result**: dp[m][n] where m = word1.length, n = word2.length\n\nLet's trace with word1=\"horse\", word2=\"ros\":\n\nBase cases:\n- dp[0][0] = 0, dp[0][1] = 1, dp[0][2] = 2, dp[0][3] = 3\n- dp[1][0] = 1, dp[2][0] = 2, dp[3][0] = 3, dp[4][0] = 4, dp[5][0] = 5\n\nFilling table:\n- dp[1][1]: 'h' != 'r' â†’ 1 + min(dp[0][1]=1, dp[1][0]=1, dp[0][0]=0) = 1\n- dp[1][2]: 'h' != 'o' â†’ 1 + min(dp[0][2]=2, dp[1][1]=1, dp[0][1]=1) = 2\n- dp[1][3]: 'h' != 's' â†’ 1 + min(dp[0][3]=3, dp[1][2]=2, dp[0][2]=2) = 3\n- dp[2][1]: 'o' != 'r' â†’ 1 + min(dp[1][1]=1, dp[2][0]=2, dp[1][0]=1) = 2\n- dp[2][2]: 'o' == 'o' â†’ dp[1][1] = 1\n- dp[2][3]: 'o' != 's' â†’ 1 + min(dp[1][3]=3, dp[2][2]=1, dp[1][2]=2) = 2\n- ... continue until dp[5][3] = 3\n\nAnswer: 3\n\nThis is O(m Ã— n) time and O(m Ã— n) space! Now let's code it step by step.",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Now let's code this solution. Which programming language would you like to use?",
      "choices": [
        {
          "label": "JavaScript",
          "next": "variable-check-js"
        },
        {
          "label": "Python",
          "next": "variable-check-python"
        },
        {
          "label": "Java",
          "next": "variable-check-java"
        },
        {
          "label": "C++",
          "next": "variable-check-cpp"
        },
        {
          "label": "TypeScript",
          "next": "variable-check-ts"
        }
      ]
    },
    {
      "stepId": "variable-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-js"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-js"
        }
      ]
    },
    {
      "stepId": "variable-explanation-js",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'm') and put data inside it.\n\nFor example, 'let m = word1.length;' creates a variable that stores the length.",
      "example": "let m = word1.length;\n\nNow the variable refers to the length",
      "action": "continue",
      "next": "function-check-js"
    },
    {
      "stepId": "function-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-js"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-js"
        }
      ]
    },
    {
      "stepId": "function-explanation-js",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a, b) {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-js"
    },
    {
      "stepId": "array-check-js",
      "mentorSays": "Before we start coding, let me ask: Do you know what a 2D array is in JavaScript?",
      "choices": [
        {
          "label": "Yes, I know 2D arrays",
          "next": "coding-start-js"
        },
        {
          "label": "No, explain 2D arrays",
          "next": "array-explanation-js"
        }
      ]
    },
    {
      "stepId": "array-explanation-js",
      "mentorSays": "A 2D array is an array of arrays. Each element is itself an array. You can access elements using two indices: arr[i][j].",
      "example": "let dp = [\n  [0, 0, 0],\n  [0, 0, 0]\n];\n\ndp[0][0] = 0\ndp[1][1] = 1",
      "action": "continue",
      "next": "coding-start-js"
    },
    {
      "stepId": "coding-start-js",
      "mentorSays": "Perfect! Let's implement edit distance in JavaScript. We'll use dynamic programming with a 2D table.",
      "example": "function minDistance(word1, word2) {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-init-js"
    },
    {
      "stepId": "coding-init-js",
      "mentorSays": "First, get the lengths of both strings and create a 2D DP table. Initialize base cases: dp[0][j] = j (insert j characters) and dp[i][0] = i (delete i characters).",
      "example": "function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n  \n  // dp[i][j] = min edits to convert word1[0..i-1] to word2[0..j-1]\n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  // Base cases: empty string conversions\n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;  // Delete i characters\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;  // Insert j characters\n  }",
      "action": "continue",
      "next": "coding-loop-js"
    },
    {
      "stepId": "coding-loop-js",
      "mentorSays": "Now, fill the DP table using nested loops. For each position, check if characters match.",
      "example": "function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n  \n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  // Fill DP table\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      // Check if characters match\n    }\n  }",
      "action": "continue",
      "next": "coding-match-js"
    },
    {
      "stepId": "coding-match-js",
      "mentorSays": "If characters match, no operation needed: dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of three operations: delete, insert, or replace.",
      "example": "function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n  \n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        // Characters match: no operation needed\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // Characters don't match: try delete, insert, or replace\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],      // delete from word1\n          dp[i][j - 1],      // insert into word1\n          dp[i - 1][j - 1]   // replace in word1\n        );\n      }\n    }\n  }",
      "action": "continue",
      "next": "coding-return-js"
    },
    {
      "stepId": "coding-return-js",
      "mentorSays": "Finally, return dp[m][n], which contains the minimum edit distance to convert word1 to word2.",
      "example": "function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n  \n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],\n          dp[i][j - 1],\n          dp[i - 1][j - 1]\n        );\n      }\n    }\n  }\n  \n  return dp[m][n];\n}",
      "action": "continue",
      "next": "test-code-js"
    },
    {
      "stepId": "test-code-js",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter calling minDistance(word1, word2), it should return:\n3\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter minDistance(word1, word2):\n3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Python?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-python"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-python"
        }
      ]
    },
    {
      "stepId": "variable-explanation-python",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'm') and put data inside it.\n\nFor example, 'm = len(word1)' creates a variable that stores the length.",
      "example": "m = len(word1)\n\nNow the variable refers to the length",
      "action": "continue",
      "next": "function-check-python"
    },
    {
      "stepId": "function-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in Python?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-python"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-python"
        }
      ]
    },
    {
      "stepId": "function-explanation-python",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "def add(a, b):\n    return a + b\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-python"
    },
    {
      "stepId": "array-check-python",
      "mentorSays": "Before we start coding, let me ask: Do you know what a 2D list is in Python?",
      "choices": [
        {
          "label": "Yes, I know 2D lists",
          "next": "coding-start-python"
        },
        {
          "label": "No, explain 2D lists",
          "next": "array-explanation-python"
        }
      ]
    },
    {
      "stepId": "array-explanation-python",
      "mentorSays": "A 2D list is a list of lists. Each element is itself a list. You can access elements using two indices: arr[i][j].",
      "example": "dp = [\n  [0, 0, 0],\n  [0, 0, 0]\n]\n\ndp[0][0] = 0\ndp[1][1] = 1",
      "action": "continue",
      "next": "coding-start-python"
    },
    {
      "stepId": "coding-start-python",
      "mentorSays": "Perfect! Let's implement edit distance in Python. We'll use dynamic programming with a 2D table.",
      "example": "def min_distance(word1, word2):\n    # Your code here\n    pass",
      "action": "continue",
      "next": "coding-init-python"
    },
    {
      "stepId": "coding-init-python",
      "mentorSays": "First, get the lengths of both strings and create a 2D DP table. Initialize base cases: dp[0][j] = j (insert j characters) and dp[i][0] = i (delete i characters).",
      "example": "def min_distance(word1, word2):\n    m = len(word1)\n    n = len(word2)\n    \n    # dp[i][j] = min edits to convert word1[0..i-1] to word2[0..j-1]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base cases: empty string conversions\n    for i in range(m + 1):\n        dp[i][0] = i  # Delete i characters\n    for j in range(n + 1):\n        dp[0][j] = j  # Insert j characters",
      "action": "continue",
      "next": "coding-loop-python"
    },
    {
      "stepId": "coding-loop-python",
      "mentorSays": "Now, fill the DP table using nested loops. For each position, check if characters match.",
      "example": "def min_distance(word1, word2):\n    m = len(word1)\n    n = len(word2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Check if characters match\n            pass",
      "action": "continue",
      "next": "coding-match-python"
    },
    {
      "stepId": "coding-match-python",
      "mentorSays": "If characters match, no operation needed: dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of three operations: delete, insert, or replace.",
      "example": "def min_distance(word1, word2):\n    m = len(word1)\n    n = len(word2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                # Characters match: no operation needed\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # Characters don't match: try delete, insert, or replace\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      # delete from word1\n                    dp[i][j - 1],      # insert into word1\n                    dp[i - 1][j - 1]   # replace in word1\n                )",
      "action": "continue",
      "next": "coding-return-python"
    },
    {
      "stepId": "coding-return-python",
      "mentorSays": "Finally, return dp[m][n], which contains the minimum edit distance to convert word1 to word2.",
      "example": "def min_distance(word1, word2):\n    m = len(word1)\n    n = len(word2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],\n                    dp[i][j - 1],\n                    dp[i - 1][j - 1]\n                )\n    \n    return dp[m][n]",
      "action": "continue",
      "next": "test-code-python"
    },
    {
      "stepId": "test-code-python",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter calling min_distance(word1, word2), it should return:\n3\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter min_distance(word1, word2):\n3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in Java?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-java"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-java"
        }
      ]
    },
    {
      "stepId": "variable-explanation-java",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'm') and put data inside it.\n\nFor example, 'int m = word1.length();' creates a variable that stores the length.",
      "example": "int m = word1.length();\n\nNow the variable refers to the length",
      "action": "continue",
      "next": "function-check-java"
    },
    {
      "stepId": "function-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a method is in Java?",
      "choices": [
        {
          "label": "Yes, I know methods",
          "next": "array-check-java"
        },
        {
          "label": "No, explain methods",
          "next": "function-explanation-java"
        }
      ]
    },
    {
      "stepId": "function-explanation-java",
      "mentorSays": "A method is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "public int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-java"
    },
    {
      "stepId": "array-check-java",
      "mentorSays": "Before we start coding, let me ask: Do you know what a 2D array is in Java?",
      "choices": [
        {
          "label": "Yes, I know 2D arrays",
          "next": "coding-start-java"
        },
        {
          "label": "No, explain 2D arrays",
          "next": "array-explanation-java"
        }
      ]
    },
    {
      "stepId": "array-explanation-java",
      "mentorSays": "A 2D array is an array of arrays. Each element is itself an array. You can access elements using two indices: arr[i][j].",
      "example": "int[][] dp = new int[2][3];\n\ndp[0][0] = 0;\ndp[1][1] = 1;",
      "action": "continue",
      "next": "coding-start-java"
    },
    {
      "stepId": "coding-start-java",
      "mentorSays": "Perfect! Let's implement edit distance in Java. We'll use dynamic programming with a 2D table.",
      "example": "public int minDistance(String word1, String word2) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-init-java"
    },
    {
      "stepId": "coding-init-java",
      "mentorSays": "First, get the lengths of both strings and create a 2D DP table. Initialize base cases: dp[0][j] = j (insert j characters) and dp[i][0] = i (delete i characters).",
      "example": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    // dp[i][j] = min edits to convert word1[0..i-1] to word2[0..j-1]\n    int[][] dp = new int[m + 1][n + 1];\n    \n    // Base cases: empty string conversions\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;  // Delete i characters\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;  // Insert j characters\n    }",
      "action": "continue",
      "next": "coding-loop-java"
    },
    {
      "stepId": "coding-loop-java",
      "mentorSays": "Now, fill the DP table using nested loops. For each position, check if characters match.",
      "example": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    // Fill DP table\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            // Check if characters match\n        }\n    }",
      "action": "continue",
      "next": "coding-match-java"
    },
    {
      "stepId": "coding-match-java",
      "mentorSays": "If characters match, no operation needed: dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of three operations: delete, insert, or replace.",
      "example": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                // Characters match: no operation needed\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Characters don't match: try delete, insert, or replace\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],      // delete from word1\n                    dp[i][j - 1],      // insert into word1\n                    dp[i - 1][j - 1]   // replace in word1\n                );\n            }\n        }\n    }",
      "action": "continue",
      "next": "coding-return-java"
    },
    {
      "stepId": "coding-return-java",
      "mentorSays": "Finally, return dp[m][n], which contains the minimum edit distance to convert word1 to word2.",
      "example": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    dp[i - 1][j],\n                    dp[i][j - 1],\n                    dp[i - 1][j - 1]\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
      "action": "continue",
      "next": "test-code-java"
    },
    {
      "stepId": "test-code-java",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter calling minDistance(word1, word2), it should return:\n3\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter minDistance(word1, word2):\n3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in C++?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-cpp"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "variable-explanation-cpp",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'm') and put data inside it.\n\nFor example, 'int m = word1.length();' creates a variable that stores the length.",
      "example": "int m = word1.length();\n\nNow the variable refers to the length",
      "action": "continue",
      "next": "function-check-cpp"
    },
    {
      "stepId": "function-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in C++?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-cpp"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "function-explanation-cpp",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "int add(int a, int b) {\n    return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-cpp"
    },
    {
      "stepId": "array-check-cpp",
      "mentorSays": "Before we start coding, let me ask: Do you know what a 2D vector is in C++?",
      "choices": [
        {
          "label": "Yes, I know 2D vectors",
          "next": "coding-start-cpp"
        },
        {
          "label": "No, explain 2D vectors",
          "next": "array-explanation-cpp"
        }
      ]
    },
    {
      "stepId": "array-explanation-cpp",
      "mentorSays": "A 2D vector is a vector of vectors. Each element is itself a vector. You can access elements using two indices: arr[i][j].",
      "example": "vector<vector<int>> dp(2, vector<int>(3, 0));\n\ndp[0][0] = 0;\ndp[1][1] = 1;",
      "action": "continue",
      "next": "coding-start-cpp"
    },
    {
      "stepId": "coding-start-cpp",
      "mentorSays": "Perfect! Let's implement edit distance in C++. We'll use dynamic programming with a 2D table.",
      "example": "int minDistance(string word1, string word2) {\n    // Your code here\n}",
      "action": "continue",
      "next": "coding-init-cpp"
    },
    {
      "stepId": "coding-init-cpp",
      "mentorSays": "First, get the lengths of both strings and create a 2D DP table. Initialize base cases: dp[0][j] = j (insert j characters) and dp[i][0] = i (delete i characters).",
      "example": "int minDistance(string word1, string word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    // dp[i][j] = min edits to convert word1[0..i-1] to word2[0..j-1]\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    // Base cases: empty string conversions\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;  // Delete i characters\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;  // Insert j characters\n    }",
      "action": "continue",
      "next": "coding-loop-cpp"
    },
    {
      "stepId": "coding-loop-cpp",
      "mentorSays": "Now, fill the DP table using nested loops. For each position, check if characters match.",
      "example": "int minDistance(string word1, string word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    // Fill DP table\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            // Check if characters match\n        }\n    }",
      "action": "continue",
      "next": "coding-match-cpp"
    },
    {
      "stepId": "coding-match-cpp",
      "mentorSays": "If characters match, no operation needed: dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of three operations: delete, insert, or replace.",
      "example": "int minDistance(string word1, string word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1[i - 1] == word2[j - 1]) {\n                // Characters match: no operation needed\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // Characters don't match: try delete, insert, or replace\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      // delete from word1\n                    dp[i][j - 1],      // insert into word1\n                    dp[i - 1][j - 1]   // replace in word1\n                );\n            }\n        }\n    }",
      "action": "continue",
      "next": "coding-return-cpp"
    },
    {
      "stepId": "coding-return-cpp",
      "mentorSays": "Finally, return dp[m][n], which contains the minimum edit distance to convert word1 to word2.",
      "example": "int minDistance(string word1, string word2) {\n    int m = word1.length();\n    int n = word2.length();\n    \n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],\n                    dp[i][j - 1],\n                    dp[i - 1][j - 1]\n                );\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
      "action": "continue",
      "next": "test-code-cpp"
    },
    {
      "stepId": "test-code-cpp",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter calling minDistance(word1, word2), it should return:\n3\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter minDistance(word1, word2):\n3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "variable-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a variable is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know variables",
          "next": "function-check-ts"
        },
        {
          "label": "No, explain variables",
          "next": "variable-explanation-ts"
        }
      ]
    },
    {
      "stepId": "variable-explanation-ts",
      "mentorSays": "A variable is like a labeled box where you can store a value. You give it a name (like 'dp' or 'm') and put data inside it.\n\nFor example, 'let m: number = word1.length;' creates a variable that stores the length.",
      "example": "let m: number = word1.length;\n\nNow the variable refers to the length",
      "action": "continue",
      "next": "function-check-ts"
    },
    {
      "stepId": "function-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a function is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know functions",
          "next": "array-check-ts"
        },
        {
          "label": "No, explain functions",
          "next": "function-explanation-ts"
        }
      ]
    },
    {
      "stepId": "function-explanation-ts",
      "mentorSays": "A function is a reusable block of code. You give it inputs (called parameters), and it can return an output.",
      "example": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(3, 5) returns 8",
      "action": "continue",
      "next": "array-check-ts"
    },
    {
      "stepId": "array-check-ts",
      "mentorSays": "Before we start coding, let me ask: Do you know what a 2D array is in TypeScript?",
      "choices": [
        {
          "label": "Yes, I know 2D arrays",
          "next": "coding-start-ts"
        },
        {
          "label": "No, explain 2D arrays",
          "next": "array-explanation-ts"
        }
      ]
    },
    {
      "stepId": "array-explanation-ts",
      "mentorSays": "A 2D array is an array of arrays. Each element is itself an array. You can access elements using two indices: arr[i][j].",
      "example": "let dp: number[][] = [\n  [0, 0, 0],\n  [0, 0, 0]\n];\n\ndp[0][0] = 0\ndp[1][1] = 1",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Let's implement edit distance in TypeScript. We'll use dynamic programming with a 2D table.",
      "example": "function minDistance(word1: string, word2: string): number {\n  // Your code here\n}",
      "action": "continue",
      "next": "coding-init-ts"
    },
    {
      "stepId": "coding-init-ts",
      "mentorSays": "First, get the lengths of both strings and create a 2D DP table. Initialize base cases: dp[0][j] = j (insert j characters) and dp[i][0] = i (delete i characters).",
      "example": "function minDistance(word1: string, word2: string): number {\n  const m: number = word1.length;\n  const n: number = word2.length;\n  \n  // dp[i][j] = min edits to convert word1[0..i-1] to word2[0..j-1]\n  const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  // Base cases: empty string conversions\n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;  // Delete i characters\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;  // Insert j characters\n  }",
      "action": "continue",
      "next": "coding-loop-ts"
    },
    {
      "stepId": "coding-loop-ts",
      "mentorSays": "Now, fill the DP table using nested loops. For each position, check if characters match.",
      "example": "function minDistance(word1: string, word2: string): number {\n  const m: number = word1.length;\n  const n: number = word2.length;\n  \n  const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  // Fill DP table\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      // Check if characters match\n    }\n  }",
      "action": "continue",
      "next": "coding-match-ts"
    },
    {
      "stepId": "coding-match-ts",
      "mentorSays": "If characters match, no operation needed: dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of three operations: delete, insert, or replace.",
      "example": "function minDistance(word1: string, word2: string): number {\n  const m: number = word1.length;\n  const n: number = word2.length;\n  \n  const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        // Characters match: no operation needed\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        // Characters don't match: try delete, insert, or replace\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],      // delete from word1\n          dp[i][j - 1],      // insert into word1\n          dp[i - 1][j - 1]   // replace in word1\n        );\n      }\n    }\n  }",
      "action": "continue",
      "next": "coding-return-ts"
    },
    {
      "stepId": "coding-return-ts",
      "mentorSays": "Finally, return dp[m][n], which contains the minimum edit distance to convert word1 to word2.",
      "example": "function minDistance(word1: string, word2: string): number {\n  const m: number = word1.length;\n  const n: number = word2.length;\n  \n  const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],\n          dp[i][j - 1],\n          dp[i - 1][j - 1]\n        );\n      }\n    }\n  }\n  \n  return dp[m][n];\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now test your code with the example we used earlier:\n\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter calling minDistance(word1, word2), it should return:\n3\n\nTry it in your IDE or code editor!",
      "example": "Test input:\nword1 = \"horse\"\nword2 = \"ros\"\n\nAfter minDistance(word1, word2):\n3",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "ðŸŽ‰ Well done! You've learned edit distance (Levenshtein distance). You understand how to use dynamic programming with a 2D table to find the minimum operations needed to convert one string to another!\n\nThis is O(m Ã— n) time and O(m Ã— n) space - excellent for string transformation problems! Keep practicing!",
      "action": "continue"
    }
  ]
}
