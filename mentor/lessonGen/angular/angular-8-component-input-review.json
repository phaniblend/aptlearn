{
  "id": "angular-8-component-input",
  "title": "Component Input",
  "technology": "Angular",
  "difficulty": "junior",
  "language": "typescript",
  "status": "draft",
  "metadata": {
    "time_estimate": "12 minutes",
    "tests": "@Input decorator, parent-child communication",
    "challenge_number": "8"
  },
  "flow": [
    {
      "stepId": "title",
      "mentorSays": "At the end of this lesson, you will be able to:\n\n1. Understand Angular's component communication patterns\n2. Use the @Input() decorator to receive data from parent components\n3. Implement property binding to pass data from parent to child\n4. Create reusable components that accept data\n5. Understand unidirectional data flow in Angular",
      "action": "continue",
      "next": "problem-illustration"
    },
    {
      "stepId": "problem-illustration",
      "mentorSays": "Let's understand Angular component input and parent-child communication.\n\n**The Challenge:**\nCreate a child component that receives data from its parent component using the @Input() decorator. The parent should be able to pass data (like a user's name and email) to the child, and the child should display it.\n\n**What We're Building:**\nA reusable child component (UserCard) that displays user information. The parent component will pass user data to this child component, demonstrating Angular's data flow pattern.\n\n**Why This Matters:**\n\nComponent communication is fundamental to Angular. In real applications, you rarely build isolated components - they need to share data. Understanding @Input() is essential for:\n- Building reusable components\n- Creating component hierarchies\n- Implementing proper data flow\n- Following Angular best practices\n\n**Real-World Applications:**\n- Product cards that receive product data\n- User profiles that display user information\n- Data tables that receive row data\n- Dashboard widgets that receive configuration\n- Any component that needs to be reusable with different data\n\n**Conceptual Foundation:**\n\nANGULAR'S DATA FLOW:\nAngular follows unidirectional data flow: Parent ‚Üí Child (one direction).\n\n```typescript\n// Parent Component\n@Component({\n  template: '<app-user-card [name]=\"userName\" />'\n})\n\n// Child Component\n@Component({\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;  // Receives data from parent\n}\n```\n\n**The @Input() Decorator:**\n\n@Input() marks a property as an input property. This means:\n- The property can receive data from a parent component\n- The data is passed via property binding `[property]=\"value\"`\n- The property is available in the child component's template\n\n**Component Communication Analogy:**\n\nThink of components like functions:\n\n```typescript\n// Function takes parameters\nfunction greet(name: string) {\n  return `Hello ${name}`;\n}\ngreet('Alice');  // Pass data\n\n// Component takes @Input properties\nclass UserCard {\n  @Input() name!: string;  // Receives data\n}\n<app-user-card [name]=\"'Alice'\" />  // Pass data\n```\n\n**Step-by-Step Example:**\n\nLet's build a UserCard component:\n\n```typescript\n// Child Component (user-card.component.ts)\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ name }}</h3>\n      <p>{{ email }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n  @Input() email!: string;\n}\n```\n\n```typescript\n// Parent Component (app.component.ts)\nimport { Component } from '@angular/core';\nimport { UserCardComponent } from './user-card.component';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <app-user-card \n      [name]=\"'John Doe'\" \n      [email]=\"'john@example.com'\"\n    />\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class AppComponent {}\n```\n\n**Property Binding Syntax:**\n\n```typescript\n// Square brackets [property] indicate property binding\n[name]=\"'John'\"     // Pass string\n[name]=\"userName\"   // Pass variable\n[name]=\"getUser()\"  // Pass function result\n```\n\n**Key Concepts:**\n\n1. **@Input() Decorator**: Marks property to receive data\n2. **Property Binding**: `[property]=\"value\"` passes data\n3. **TypeScript Types**: Use `!` for required inputs, `?` for optional\n4. **Template Interpolation**: `{{ property }}` displays data\n5. **Standalone Components**: Modern Angular (no NgModule needed)\n\n**Multiple Inputs:**\n\n```typescript\n@Component({\n  selector: 'app-product-card',\n  template: `\n    <div>\n      <h3>{{ title }}</h3>\n      <p>Price: ${{ price }}</p>\n      <p>Stock: {{ inStock ? 'Available' : 'Out of Stock' }}</p>\n    </div>\n  `\n})\nexport class ProductCardComponent {\n  @Input() title!: string;\n  @Input() price!: number;\n  @Input() inStock!: boolean;\n}\n```\n\n**Optional vs Required Inputs:**\n\n```typescript\n// Required input (must be provided)\n@Input() name!: string;\n\n// Optional input (can be undefined)\n@Input() description?: string;\n```\n\n**@Input() Pattern Variations:**\n\nAngular provides flexibility in how you define and use @Input() properties.\n\n**PATTERN 1: Basic @Input() (Most Common)**\n\n```typescript\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n}\n```\n\n**Advantages:**\n‚úì Simple and straightforward\n‚úì Clear intent\n‚úì Works for most use cases\n\n**When to use:** Standard component inputs, required data\n\n---\n\n**PATTERN 2: @Input() with Alias**\n\n```typescript\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input('userName') name!: string;  // External name differs from internal\n}\n```\n\n**Usage:**\n```html\n<app-user-card [userName]=\"'John'\" />  <!-- Uses alias -->\n```\n\n**Advantages:**\n‚úì External API can differ from internal property name\n‚úì Better encapsulation\n‚úì Can rename without breaking parent components\n\n**When to use:** When you want different external/internal names\n\n---\n\n**PATTERN 3: Optional @Input()**\n\n```typescript\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3><p>{{ description || 'No description' }}</p>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n  @Input() description?: string;  // Optional with ?\n}\n```\n\n**Usage:**\n```html\n<app-user-card [name]=\"'John'\" />  <!-- description is optional -->\n<app-user-card [name]=\"'John'\" [description]=\"'Developer'\" />  <!-- or provided -->\n```\n\n**Advantages:**\n‚úì Flexible component API\n‚úì Some inputs can be optional\n‚úì Better for reusable components\n\n**When to use:** When some inputs aren't always needed\n\n---\n\n**PATTERN 4: @Input() with Default Values**\n\n```typescript\n@Component({\n  selector: 'app-button',\n  template: '<button [disabled]=\"disabled\">{{ label }}</button>'\n})\nexport class ButtonComponent {\n  @Input() label: string = 'Click Me';  // Default value\n  @Input() disabled: boolean = false;   // Default value\n}\n```\n\n**Advantages:**\n‚úì Components work even without all inputs\n‚úì Sensible defaults\n‚úì Easier to use\n\n**When to use:** When you want sensible defaults\n\n---\n\n**Pattern Comparison:**\n\n```typescript\n// Pattern 1: Required input\n@Input() name!: string;  // Must be provided\n\n// Pattern 2: Optional input\n@Input() description?: string;  // May be undefined\n\n// Pattern 3: Input with default\n@Input() count: number = 0;  // Defaults to 0\n\n// Pattern 4: Input with alias\n@Input('externalName') internalName!: string;  // Different names\n```\n\n**Which should YOU use?**\n\nFor learning Angular:\n- Start with **Pattern 1** (basic @Input())\n- It's the most common and straightforward\n- Clear and explicit\n- Easiest to understand\n\nAs you gain experience:\n- Use Pattern 2 when you need different external/internal names\n- Use Pattern 3 for optional data\n- Use Pattern 4 for components with sensible defaults\n\n---\n\n**File Organization Best Practices:**\n\nAngular projects organize components in a structured way:\n\n```\nsrc/\n  app/\n    components/\n      user-card/\n        user-card.component.ts    ‚Üê Component class\n        user-card.component.html   ‚Üê Template\n        user-card.component.css    ‚Üê Styles\n      product-card/\n        product-card.component.ts\n        product-card.component.html\n        product-card.component.css\n    app.component.ts               ‚Üê Root component\n    app.component.html\n```\n\n**Key principles:**\n1. **One component per folder** - Keeps related files together\n2. **Component naming** - `user-card.component.ts` for `UserCardComponent`\n3. **Separate files** - `.ts` for logic, `.html` for template, `.css` for styles\n4. **Group related components** - Keep similar components together\n5. **Standalone components** - Modern Angular (no NgModule needed)\n\n---\n\n**Common Beginner Mistakes and How to Avoid Them:**\n\n**MISTAKE 1: Forgetting the @Input() decorator**\n\n‚ùå **Wrong:**\n```typescript\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  name!: string;  // Missing @Input()!\n}\n```\n\n‚úì **Correct:**\n```typescript\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;  // Has @Input()!\n}\n```\n\n**Why it matters:** Without @Input(), Angular doesn't know this property can receive data from parent.\n\n---\n\n**MISTAKE 2: Using interpolation instead of property binding**\n\n‚ùå **Wrong:**\n```html\n<app-user-card name=\"{{ userName }}\"></app-user-card>  <!-- Interpolation in attribute -->\n```\n\n‚úì **Correct:**\n```html\n<app-user-card [name]=\"userName\"></app-user-card>  <!-- Property binding -->\n```\n\n**Why it matters:** Interpolation in attributes passes strings. Property binding passes actual values.\n\n---\n\n**MISTAKE 3: Missing square brackets in property binding**\n\n‚ùå **Wrong:**\n```html\n<app-user-card name=\"userName\"></app-user-card>  <!-- Passes string 'userName' -->\n```\n\n‚úì **Correct:**\n```html\n<app-user-card [name]=\"userName\"></app-user-card>  <!-- Passes variable value -->\n```\n\n**Why it matters:** Without brackets, Angular treats it as a string literal, not a property reference.\n\n---\n\n**MISTAKE 4: Forgetting to import child component**\n\n‚ùå **Wrong:**\n```typescript\n@Component({\n  selector: 'app-parent',\n  template: '<app-user-card [name]=\"userName\"></app-user-card>',\n  standalone: true\n  // Missing imports!\n})\nexport class ParentComponent {}\n```\n\n‚úì **Correct:**\n```typescript\n@Component({\n  selector: 'app-parent',\n  template: '<app-user-card [name]=\"userName\"></app-user-card>',\n  standalone: true,\n  imports: [UserCardComponent]  // Import child component!\n})\nexport class ParentComponent {}\n```\n\n**Why it matters:** Standalone components must explicitly import dependencies.\n\n---\n\n**MISTAKE 5: Using wrong TypeScript syntax for required inputs**\n\n‚ùå **Wrong:**\n```typescript\n@Input() name: string;  // TypeScript error: may be undefined\n```\n\n‚úì **Correct:**\n```typescript\n@Input() name!: string;  // ! tells TypeScript it will be provided\n```\n\n**Why it matters:** The `!` operator tells TypeScript the value will be set by the parent, avoiding undefined errors.\n\n---\n\n**Real-World Component Examples:**\n\n**Example 1: Product Card Component**\n```typescript\n@Component({\n  selector: 'app-product-card',\n  template: `\n    <div class=\"product-card\">\n      <h3>{{ title }}</h3>\n      <p class=\"price\">${{ price }}</p>\n      <p class=\"stock\">{{ inStock ? 'In Stock' : 'Out of Stock' }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class ProductCardComponent {\n  @Input() title!: string;\n  @Input() price!: number;\n  @Input() inStock!: boolean;\n}\n```\n\n**Example 2: User Profile Component**\n```typescript\n@Component({\n  selector: 'app-user-profile',\n  template: `\n    <div class=\"profile\">\n      <img [src]=\"avatarUrl\" [alt]=\"name\" />\n      <h2>{{ name }}</h2>\n      <p>{{ email }}</p>\n      <p>{{ bio || 'No bio available' }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserProfileComponent {\n  @Input() name!: string;\n  @Input() email!: string;\n  @Input() avatarUrl!: string;\n  @Input() bio?: string;  // Optional\n}\n```\n\n**Example 3: Data Table Row Component**\n```typescript\n@Component({\n  selector: 'app-table-row',\n  template: `\n    <tr>\n      <td>{{ id }}</td>\n      <td>{{ name }}</td>\n      <td>{{ status }}</td>\n      <td>{{ date | date }}</td>\n    </tr>\n  `,\n  standalone: true\n})\nexport class TableRowComponent {\n  @Input() id!: number;\n  @Input() name!: string;\n  @Input() status!: string;\n  @Input() date!: Date;\n}\n```\n\n**Notice in all examples:**\n- Clear @Input() decorators\n- Proper TypeScript types\n- Template interpolation for display\n- Standalone components\n- Reusable and flexible\n\n---\n\n**Next Steps After This Lesson:**\n\nOnce you master @Input(), you'll learn:\n\n1. **@Output()** - Send data from child to parent\n   ```typescript\n   @Output() clicked = new EventEmitter();\n   ```\n\n2. **Two-Way Binding** - Bidirectional data flow\n   ```typescript\n   [(ngModel)]=\"value\"\n   ```\n\n3. **Input Transformations** - Modify input values\n   ```typescript\n   @Input({ transform: booleanAttribute }) isActive!: boolean;\n   ```\n\n4. **Input Setters** - React to input changes\n   ```typescript\n   @Input() set name(value: string) { ... }\n   ```\n\n5. **Component Lifecycle** - Respond to input changes\n   ```typescript\n   ngOnChanges(changes: SimpleChanges) { ... }\n   ```\n\nAll of these build on the @Input() pattern you're learning here!\n\n---\n\n**Summary:**\n\nUsing @Input() involves:\n1. ‚úÖ Mark property with @Input() decorator\n2. ‚úÖ Use property binding `[property]=\"value\"` in parent\n3. ‚úÖ Display data with interpolation `{{ property }}`\n4. ‚úÖ Import child component in parent\n5. ‚úÖ Use TypeScript types for safety\n\nMaster this pattern, and you'll build reusable, maintainable Angular components!\n\n**Time estimate:** 12 minutes\n**Difficulty level:** Junior\n\nThis pattern is used in every Angular application - master it and you'll build reusable, maintainable components!",
      "example": "// Child Component\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n}\n\n// Parent Component\n<app-user-card [name]=\"'John'\" />",
      "action": "continue",
      "next": "thinking-challenge"
    },
    {
      "stepId": "thinking-challenge",
      "mentorSays": "Now that you understand component input, here's the real question:\n\nHow would YOU create a component that receives data from its parent?\n\nThink about it - what pieces do you need?",
      "choices": [
        {"label": "I'll start with the child component and add @Input", "next": "explore-approach-1"},
        {"label": "I want to see the complete solution", "next": "explore-optimal"},
        {"label": "I need more context", "next": "problem-illustration"}
      ]
    },
    {
      "stepId": "explore-approach-1",
      "mentorSays": "Perfect! Starting with the child component is the right approach. We'll add @Input properties, then show how the parent passes data.",
      "action": "continue",
      "next": "explore-optimal"
    },
    {
      "stepId": "explore-optimal",
      "mentorSays": "Excellent! Here's the optimal solution:\n\n```typescript\n// Child Component\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ name }}</h3>\n      <p>{{ email }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n  @Input() email!: string;\n}\n\n// Parent Component\n@Component({\n  selector: 'app-parent',\n  template: `\n    <app-user-card \n      [name]=\"'John Doe'\" \n      [email]=\"'john@example.com'\"\n    />\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class ParentComponent {}\n```\n\nThis demonstrates Angular's unidirectional data flow pattern. Let's build it step by step!",
      "example": "// Complete parent-child communication example",
      "action": "continue",
      "next": "language-selection"
    },
    {
      "stepId": "language-selection",
      "mentorSays": "Great! Since this is an Angular challenge, we'll use TypeScript. Let's start coding!",
      "action": "continue",
      "next": "component-check"
    },
    {
      "stepId": "component-check",
      "mentorSays": "Before we start, let me check: Do you understand Angular components and the @Component decorator?",
      "choices": [
        {"label": "Yes, I understand components", "next": "decorator-check"},
        {"label": "No, please explain", "next": "component-explanation"}
      ]
    },
    {
      "stepId": "component-explanation",
      "mentorSays": "Angular components are the building blocks of Angular applications. Let me explain:\n\n**What is a Component?**\n\nA component in Angular consists of:\n1. **TypeScript Class**: Contains component logic\n2. **Template**: HTML that defines the view\n3. **Decorator**: @Component metadata\n4. **Styles**: Component-specific CSS (optional)\n\n**Basic Component Structure:**\n\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',  // How you use it\n  template: '<h1>Hello</h1>',  // What it displays\n  standalone: true  // Modern Angular (no NgModule)\n})\nexport class ExampleComponent {\n  // Component logic here\n}\n```\n\n**The @Component Decorator:**\n\nThe @Component decorator tells Angular this class is a component. It provides metadata:\n- `selector`: HTML tag name (like `<app-example>`)\n- `template`: HTML template (what to display)\n- `standalone`: Modern Angular feature (makes component independent)\n\n**Component Usage:**\n\n```typescript\n// Define component\n@Component({\n  selector: 'app-greeting',\n  template: '<p>Hello World</p>',\n  standalone: true\n})\nexport class GreetingComponent {}\n\n// Use it in template\n<app-greeting></app-greeting>\n```\n\n**Components are Reusable:**\n\n```typescript\n// Use the same component multiple times\n<app-greeting></app-greeting>\n<app-greeting></app-greeting>\n<app-greeting></app-greeting>\n```\n\n**Key Points:**\n- Components are TypeScript classes\n- @Component decorator provides metadata\n- Template defines the view\n- Selector is how you use it\n- Standalone components are modern Angular\n\nNow you understand components - they're classes with templates!",
      "example": "@Component({\n  selector: 'app-example',\n  template: '<h1>Hello</h1>',\n  standalone: true\n})\nexport class ExampleComponent {}",
      "action": "continue",
      "next": "decorator-check"
    },
    {
      "stepId": "decorator-check",
      "mentorSays": "Do you understand TypeScript decorators like @Component and @Input?",
      "choices": [
        {"label": "Yes, I understand decorators", "next": "property-binding-check"},
        {"label": "No, please explain", "next": "decorator-explanation"}
      ]
    },
    {
      "stepId": "decorator-explanation",
      "mentorSays": "Decorators are special functions that modify classes, methods, or properties. In Angular, decorators provide metadata to the framework.\n\n**What are Decorators?**\n\nDecorators are functions prefixed with `@` that modify or add information to code.\n\n**Common Angular Decorators:**\n\n```typescript\n// @Component - Marks a class as a component\n@Component({\n  selector: 'app-user',\n  template: '...'\n})\nexport class UserComponent {}\n\n// @Input() - Marks a property to receive data from parent\n@Input() name!: string;\n\n// @Output() - Marks an EventEmitter to send data to parent\n@Output() clicked = new EventEmitter();\n\n// @Injectable() - Marks a class as a service\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {}\n```\n\n**How @Input() Works:**\n\n```typescript\nclass UserCardComponent {\n  @Input() name!: string;  // Decorator marks this as input\n}\n```\n\nThe @Input() decorator:\n- Tells Angular this property can receive data\n- Enables property binding from parent\n- Makes the property available in template\n\n**Without Decorator:**\n```typescript\n// ‚ùå Can't receive data from parent\nclass UserCardComponent {\n  name!: string;  // Just a regular property\n}\n```\n\n**With Decorator:**\n```typescript\n// ‚úÖ Can receive data from parent\nclass UserCardComponent {\n  @Input() name!: string;  // Input property\n}\n```\n\n**Decorator Syntax:**\n\n```typescript\n// Decorator before property\n@Input() name!: string;\n\n// Decorator before class\n@Component({...})\nexport class MyComponent {}\n\n// Decorator before method\n@HostListener('click')\nhandleClick() {}\n```\n\n**Key Points:**\n- Decorators start with `@`\n- They modify or add metadata\n- Angular uses them extensively\n- @Input() enables parent-child communication\n\nDecorators are Angular's way of adding special behavior to your code!",
      "example": "// @Input decorator example\nclass UserCardComponent {\n  @Input() name!: string;  // Receives data\n  @Input() age?: number;   // Optional input\n}\n\n// Usage:\n<app-user-card [name]=\"'John'\" />",
      "action": "continue",
      "next": "property-binding-check"
    },
    {
      "stepId": "property-binding-check",
      "mentorSays": "Do you understand property binding syntax `[property]=\"value\"` in Angular templates?",
      "choices": [
        {"label": "Yes, I understand property binding", "next": "typescript-check"},
        {"label": "No, please explain", "next": "property-binding-explanation"}
      ]
    },
    {
      "stepId": "property-binding-explanation",
      "mentorSays": "Property binding lets you set element or component properties dynamically. The square brackets `[property]` indicate property binding.\n\n**What is Property Binding?**\n\nProperty binding sets a property value from a component's data.\n\n**Syntax:**\n```html\n[property]=\"expression\"\n```\n\n**Examples:**\n\n```html\n<!-- Bind to HTML element property -->\n<img [src]=\"imageUrl\" />\n<button [disabled]=\"isDisabled\">Click</button>\n<div [hidden]=\"isHidden\">Content</div>\n\n<!-- Bind to component @Input property -->\n<app-user-card [name]=\"userName\" />\n<app-product [price]=\"productPrice\" />\n```\n\n**Property Binding vs Interpolation:**\n\n```html\n<!-- Interpolation: Display value -->\n<p>{{ userName }}</p>\n\n<!-- Property Binding: Set property -->\n<app-user-card [name]=\"userName\" />\n```\n\n**Different Binding Types:**\n\n```html\n<!-- String binding -->\n[title]=\"'Hello'\"\n[name]=\"userName\"\n\n<!-- Boolean binding -->\n[disabled]=\"true\"\n[hidden]=\"isHidden\"\n\n<!-- Number binding -->\n[count]=\"5\"\n[price]=\"productPrice\"\n\n<!-- Object binding -->\n[user]=\"currentUser\"\n```\n\n**Key Points:**\n- Square brackets `[]` indicate property binding\n- Expression inside quotes is evaluated\n- Can bind to HTML properties or component inputs\n- One-way binding (parent ‚Üí child)\n\n**Example:**\n\n```typescript\n// Component\nexport class AppComponent {\n  userName = 'John';\n  isActive = true;\n}\n```\n\n```html\n<!-- Template -->\n<app-user-card [name]=\"userName\" />\n<button [disabled]=\"!isActive\">Submit</button>\n```\n\nProperty binding connects component data to template properties!",
      "example": "// Component\nexport class AppComponent {\n  userName = 'Alice';\n}\n\n// Template\n<app-user-card [name]=\"userName\" />",
      "action": "continue",
      "next": "typescript-check"
    },
    {
      "stepId": "typescript-check",
      "mentorSays": "Do you understand TypeScript type annotations and the `!` operator for required properties?",
      "choices": [
        {"label": "Yes, I understand TypeScript types", "next": "template-check"},
        {"label": "No, please explain", "next": "typescript-explanation"}
      ]
    },
    {
      "stepId": "typescript-explanation",
      "mentorSays": "TypeScript adds types to JavaScript. In Angular, we use types to make our code safer and clearer.\n\n**What is TypeScript?**\n\nTypeScript is JavaScript with types. Types tell you what kind of data a variable can hold.\n\n**Basic Types:**\n\n```typescript\n// String type\nlet name: string = 'John';\n\n// Number type\nlet age: number = 25;\n\n// Boolean type\nlet isActive: boolean = true;\n\n// Array type\nlet items: string[] = ['a', 'b', 'c'];\n```\n\n**The `!` Operator (Non-null Assertion):**\n\nThe `!` operator tells TypeScript: \"I promise this value will be set, don't worry about it being undefined.\"\n\n```typescript\n// Without ! - TypeScript thinks it might be undefined\n@Input() name?: string;  // Optional, might be undefined\n\n// With ! - TypeScript knows it will be set\n@Input() name!: string;  // Required, will be provided\n```\n\n**Why Use `!` for @Input()?**\n\nWhen you use `@Input() name!: string`, you're telling TypeScript:\n- This property WILL receive a value from the parent\n- Don't require initialization in the constructor\n- Trust that the parent will provide it\n\n**Example:**\n\n```typescript\n// Component with @Input\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;  // ! means \"will be provided\"\n  @Input() email?: string;  // ? means \"optional\"\n}\n```\n\n**Type Safety Benefits:**\n\n```typescript\n// TypeScript catches errors at compile time\n@Input() name!: string;\n\n// Later in code:\nthis.name.toUpperCase();  // ‚úÖ TypeScript knows name is string\nthis.name = 123;  // ‚ùå Error! Can't assign number to string\n```\n\n**Key Points:**\n- TypeScript adds type safety\n- `!` means \"definitely assigned\"\n- `?` means \"optional\"\n- Types help catch errors early\n\nTypeScript makes Angular code safer and more maintainable!",
      "example": "// TypeScript with @Input\n@Component({\n  selector: 'app-user-card',\n  template: '<h3>{{ name }}</h3>'\n})\nexport class UserCardComponent {\n  @Input() name!: string;  // Required\n  @Input() age?: number;   // Optional\n}",
      "action": "continue",
      "next": "template-check"
    },
    {
      "stepId": "template-check",
      "mentorSays": "Do you understand Angular template interpolation `{{ }}` for displaying data?",
      "choices": [
        {"label": "Yes, I understand templates", "next": "coding-start-ts"},
        {"label": "No, please explain", "next": "template-explanation"}
      ]
    },
    {
      "stepId": "template-explanation",
      "mentorSays": "Angular templates use special syntax to display data and bind to component properties.\n\n**What is Template Interpolation?**\n\nInterpolation uses `{{ }}` to display component data in templates.\n\n**Basic Interpolation:**\n\n```html\n<!-- Component -->\nexport class MyComponent {\n  name = 'John';\n  age = 25;\n}\n\n<!-- Template -->\n<p>Hello {{ name }}</p>\n<p>Age: {{ age }}</p>\n\n<!-- Renders as: -->\n<p>Hello John</p>\n<p>Age: 25</p>\n```\n\n**Interpolation vs Property Binding:**\n\n```html\n<!-- Interpolation: Display value -->\n<p>{{ userName }}</p>\n\n<!-- Property Binding: Set property -->\n<app-user-card [name]=\"userName\" />\n```\n\n**What Can You Interpolate?**\n\n```html\n<!-- Variables -->\n<p>{{ name }}</p>\n\n<!-- Expressions -->\n<p>{{ 2 + 2 }}</p>\n<p>{{ name.toUpperCase() }}</p>\n\n<!-- Method calls -->\n<p>{{ getUserName() }}</p>\n\n<!-- Ternary operator -->\n<p>{{ isActive ? 'Active' : 'Inactive' }}</p>\n```\n\n**Key Points:**\n- `{{ }}` displays component data\n- Can use expressions, methods, operators\n- One-way binding (component ‚Üí template)\n- Automatically updates when data changes\n\n**Example:**\n\n```typescript\n@Component({\n  selector: 'app-user',\n  template: `\n    <div>\n      <h3>{{ name }}</h3>\n      <p>Email: {{ email }}</p>\n      <p>Status: {{ isActive ? 'Active' : 'Inactive' }}</p>\n    </div>\n  `\n})\nexport class UserComponent {\n  name = 'John';\n  email = 'john@example.com';\n  isActive = true;\n}\n```\n\nTemplate interpolation displays your component's data!",
      "example": "// Component\nexport class UserComponent {\n  name = 'Alice';\n}\n\n// Template\n<h3>{{ name }}</h3>",
      "action": "continue",
      "next": "coding-start-ts"
    },
    {
      "stepId": "coding-start-ts",
      "mentorSays": "Perfect! Now let's build the component input solution step by step. We'll create both the child and parent components.",
      "action": "continue",
      "next": "coding-step-1-ts"
    },
    {
      "stepId": "coding-step-1-ts",
      "mentorSays": "First, let's import the necessary Angular modules. We need Component and Input from @angular/core.",
      "example": "import { Component, Input } from '@angular/core';",
      "action": "continue",
      "next": "coding-step-2-ts"
    },
    {
      "stepId": "coding-step-2-ts",
      "mentorSays": "Now let's create the child component with the @Component decorator. We'll set up the selector and template.",
      "example": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ name }}</h3>\n      <p>{{ email }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserCardComponent {\n  // Properties will go here\n}",
      "action": "continue",
      "next": "coding-step-3-ts"
    },
    {
      "stepId": "coding-step-3-ts",
      "mentorSays": "Now let's add the @Input() properties. These will receive data from the parent component.",
      "example": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ name }}</h3>\n      <p>{{ email }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n  @Input() email!: string;\n}",
      "action": "continue",
      "next": "coding-step-4-ts"
    },
    {
      "stepId": "coding-step-4-ts",
      "mentorSays": "Great! Now let's create the parent component that will use our child component. First, we'll set up the basic parent component structure.",
      "example": "import { Component } from '@angular/core';\nimport { UserCardComponent } from './user-card.component';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div>\n      <app-user-card></app-user-card>\n    </div>\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class ParentComponent {}",
      "action": "continue",
      "next": "coding-step-5-ts"
    },
    {
      "stepId": "coding-step-5-ts",
      "mentorSays": "Now let's add property binding to pass data from the parent to the child. We use square brackets `[property]=\"value\"` to bind values to the child component's @Input properties.",
      "example": "import { Component } from '@angular/core';\nimport { UserCardComponent } from './user-card.component';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div>\n      <app-user-card \n        [name]=\"'John Doe'\" \n        [email]=\"'john@example.com'\"\n      ></app-user-card>\n    </div>\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class ParentComponent {}",
      "action": "continue",
      "next": "coding-step-6-ts"
    },
    {
      "stepId": "coding-step-6-ts",
      "mentorSays": "Excellent! Now let's enhance this by using component properties instead of hardcoded strings. This makes the parent component more flexible and demonstrates how to bind to component data.",
      "example": "import { Component } from '@angular/core';\nimport { UserCardComponent } from './user-card.component';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div>\n      <app-user-card \n        [name]=\"userName\" \n        [email]=\"userEmail\"\n      ></app-user-card>\n    </div>\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class ParentComponent {\n  userName = 'John Doe';\n  userEmail = 'john@example.com';\n}",
      "action": "continue",
      "next": "coding-complete-ts"
    },
    {
      "stepId": "coding-complete-ts",
      "mentorSays": "Perfect! Here's the complete solution with both components using component properties:",
      "example": "// user-card.component.ts (Child)\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ name }}</h3>\n      <p>{{ email }}</p>\n    </div>\n  `,\n  standalone: true\n})\nexport class UserCardComponent {\n  @Input() name!: string;\n  @Input() email!: string;\n}\n\n// parent.component.ts (Parent)\nimport { Component } from '@angular/core';\nimport { UserCardComponent } from './user-card.component';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div>\n      <app-user-card \n        [name]=\"userName\" \n        [email]=\"userEmail\"\n      ></app-user-card>\n    </div>\n  `,\n  standalone: true,\n  imports: [UserCardComponent]\n})\nexport class ParentComponent {\n  userName = 'John Doe';\n  userEmail = 'john@example.com';\n}",
      "action": "continue",
      "next": "test-code-ts"
    },
    {
      "stepId": "test-code-ts",
      "mentorSays": "Perfect! Now let's test your components and make sure everything works correctly.\n\n**Testing Steps:**\n\n1. **Create component files:**\n   - Create `user-card.component.ts` in `src/app/components/`\n   - Create `parent.component.ts` in `src/app/`\n   - Paste the respective component code\n   - Save both files\n\n2. **Import in parent component:**\n   ```typescript\n   import { UserCardComponent } from './components/user-card.component';\n   ```\n\n3. **Use property binding in template:**\n   ```html\n   <app-user-card \n     [name]=\"userName\" \n     [email]=\"userEmail\"\n   ></app-user-card>\n   ```\n\n4. **Run your Angular app:**\n   ```bash\n   ng serve\n   ```\n\n5. **Verify in browser:**\n   - Open http://localhost:4200\n   - You should see the user card with name and email!\n\n**Expected Result:**\n\nYour browser should display:\n- A card with \"John Doe\" as the heading\n- The email \"john@example.com\" below it\n- Proper styling (if CSS is added)\n\n**Common Issues and Solutions:**\n\n**Problem 1: Component doesn't appear**\n```\nSymptom: Nothing shows on screen\nSolution: Check that UserCardComponent is in imports array\n         Check that selector matches: 'app-user-card'\n         Verify component is imported correctly\n         Check browser console for errors\n```\n\n**Problem 2: Property binding not working**\n```\nSymptom: Shows empty or undefined values\nSolution: Check square brackets are present: [name] not name\n         Verify @Input() decorator is on property\n         Check property name matches in binding\n         Ensure parent has the data property defined\n```\n\n**Problem 3: TypeScript compilation error**\n```\nSymptom: Red errors in IDE or build fails\nSolution: Check TypeScript types match\n         Verify ! operator for required inputs\n         Check all imports are correct\n         Ensure standalone: true is set\n```\n\n**Problem 4: Template parse error**\n```\nSymptom: Angular template errors\nSolution: Check property binding syntax: [property]=\"value\"\n         Verify template uses backticks for multi-line\n         Check all quotes are matched\n         Ensure component selector is correct\n```\n\n**Problem 5: Data not displaying**\n```\nSymptom: Component renders but shows no data\nSolution: Check interpolation syntax: {{ property }}\n         Verify @Input() property name matches template\n         Check parent is passing data correctly\n         Ensure property is defined in component class\n```\n\n**Try These Experiments:**\n\nOnce it's working, try modifying:\n\n1. **Pass different data:**\n   ```typescript\n   export class ParentComponent {\n     userName = 'Alice Smith';\n     userEmail = 'alice@example.com';\n   }\n   ```\n\n2. **Add more @Input properties:**\n   ```typescript\n   @Input() age!: number;\n   @Input() phone?: string;\n   ```\n\n3. **Use multiple components:**\n   ```html\n   <app-user-card [name]=\"'John'\" [email]=\"'john@example.com'\"></app-user-card>\n   <app-user-card [name]=\"'Jane'\" [email]=\"'jane@example.com'\"></app-user-card>\n   ```\n\n4. **Bind to object properties:**\n   ```typescript\n   export class ParentComponent {\n     user = { name: 'Bob', email: 'bob@example.com' };\n   }\n   ```\n   ```html\n   <app-user-card [name]=\"user.name\" [email]=\"user.email\"></app-user-card>\n   ```\n\n5. **Add optional input:**\n   ```typescript\n   @Input() description?: string;\n   ```\n   ```html\n   <p>{{ description || 'No description available' }}</p>\n   ```\n\n**Success Indicators:**\n\n‚úÖ Component renders without errors\n‚úÖ Name and email display correctly\n‚úÖ Property binding works\n‚úÖ Multiple components work independently\n‚úÖ Changes to parent data reflect in child\n‚úÖ No console errors\n‚úÖ TypeScript compiles successfully\n\nYou've successfully created and tested Angular component input communication!",
      "example": "// Test with different data\n<app-user-card \n  [name]=\"'Alice Smith'\" \n  [email]=\"'alice@example.com'\"\n/>\n\n<app-user-card \n  [name]=\"'Bob Johnson'\" \n  [email]=\"'bob@example.com'\"\n/>",
      "action": "continue",
      "next": "final"
    },
    {
      "stepId": "final",
      "mentorSays": "üéâ Well done! You've mastered Angular component input!\n\n**Key Takeaways:**\n- @Input() decorator marks properties that receive data from parent\n- Property binding `[property]=\"value\"` passes data from parent to child\n- Angular follows unidirectional data flow (parent ‚Üí child)\n- Components become reusable when they accept inputs\n- TypeScript types ensure type safety for inputs\n\n**What You've Learned:**\n- How to create components that receive data\n- Property binding syntax and usage\n- Parent-child component communication\n- Reusable component patterns\n\n**Next Steps:**\n- Learn @Output() for child-to-parent communication\n- Explore two-way binding with ngModel\n- Build more complex component hierarchies\n- Practice with different data types (objects, arrays)\n\n**Related Challenges:**\n- Component Output - Send data from child to parent\n- Two-Way Binding - Bidirectional data flow\n- Event Handling - Make components interactive\n- Component Lifecycle - Understand component lifecycle hooks\n\nKeep practicing! Component communication is essential for building Angular applications.",
      "action": "continue"
    }
  ]
}

